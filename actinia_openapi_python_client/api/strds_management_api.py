# coding: utf-8

"""
    Actinia

     ================================ Actinia - The GRASS GIS REST API ================================  **Actinia** is an open source REST API for scalable, distributed, high performance processing of geographical data that uses GRASS GIS for computational tasks.  It provides a REST API to process satellite images, time series of satellite images, arbitrary raster data with geographical relations and vector data.  The REST interface allows to access, manage and manipulate the GRASS GIS database via HTTP GET,PUT,POST and DELETE requests and to process raster, vector and time series data located in a persistent GRASS GIS database. **Actinia** allows the processing of cloud based data, for example all Landsat 4-8 scenes as well as all Sentinel2A scenes in an ephemeral databases. The computational results of ephemeral processing are available via object storage as GeoTIFF files.  The full API documentation is available here: https://redocly.github.io/redoc/?url=https://actinia.mundialis.de/latest/ swagger.json   Examples: ---------  To execute the examples, first setup login information, IP address and port:      export ACTINIA_URL=https://actinia.mundialis.de/latest     export AUTH='-u demouser:gu3st!pa55w0rd'  **Data management**  - List all locations that are available in the actinia persistent database:      curl ${AUTH} -X GET \"${ACTINIA_URL}/locations\"  - List all mapsets in the location latlong_wgs84:      curl ${AUTH} -X GET \"${ACTINIA_URL}/locations/latlong_wgs84/mapsets\"  - List all raster layers in location latlong_wgs84 and mapset Sentinel2A      curl ${AUTH} -X GET     \"${ACTINIA_URL}/locations/latlong_wgs84/mapsets/Sentinel2A/raster_layers\"  - List all space-time raster datasets (STRDS) in location ECAD and mapset   PERMANENT:      curl ${AUTH} -X GET     \"${ACTINIA_URL}/locations/ECAD/mapsets/PERMANENT/raster_layers\"  - List all raster map layers of the STRDS precipitation_1950_2013_yearly_mm:      curl ${AUTH} -X GET     \"${ACTINIA_URL}/locations/ECAD/mapsets/PERMANENT/strds/precipitation_    1950_2013_yearly_mm/raster_layers\"  **Landsat and Sentinel2A NDVI computation**  This API call will compute the NDVI of the top of atmosphere (TOAR) corrected Landsat4 scene LC80440342016259LGN00:      curl ${AUTH} -X POST \"${ACTINIA_URL}/landsat_process/    LC80440342016259LGN00/TOAR/NDVI\"  NDVI computation of Sentinel2A scene S2A_MSIL1C_20170212T104141_N0204_R008_T31TGJ_20170212T104138:      curl ${AUTH} -X POST \"${ACTINIA_URL}/sentinel2_process/ndvi/    S2A_MSIL1C_20170212T104141_N0204_R008_T31TGJ_20170212T104138\"  The results of the asynchronous computations are available as GeoTIFF file in a cloud storage for download. 

    The version of the OpenAPI document: v3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictBool, StrictFloat, StrictInt, StrictStr

from typing import List, Optional, Union

from actinia_openapi_python_client.models.processing_response_model import ProcessingResponseModel
from actinia_openapi_python_client.models.raster_list_entry_model import RasterListEntryModel
from actinia_openapi_python_client.models.strds_creation_model import STRDSCreationModel
from actinia_openapi_python_client.models.strds_info_response_model import STRDSInfoResponseModel
from actinia_openapi_python_client.models.strds_raster_list_response_model import STRDSRasterListResponseModel
from actinia_openapi_python_client.models.string_list_processing_result_response_model import StringListProcessingResultResponseModel

from actinia_openapi_python_client.api_client import ApiClient
from actinia_openapi_python_client.api_response import ApiResponse
from actinia_openapi_python_client.rest import RESTResponseType


class STRDSManagementApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_get(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        where: Annotated[Optional[StrictStr], Field(description="A where statement to select user specific STRDS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> StringListProcessingResultResponseModel:
        """Get a list of all STRDS that are located in a specific location/mapset.

        Get a list of all STRDS that are located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param where: A where statement to select user specific STRDS
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StringListProcessingResultResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_get_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        where: Annotated[Optional[StrictStr], Field(description="A where statement to select user specific STRDS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[StringListProcessingResultResponseModel]:
        """Get a list of all STRDS that are located in a specific location/mapset.

        Get a list of all STRDS that are located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param where: A where statement to select user specific STRDS
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StringListProcessingResultResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_get_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        where: Annotated[Optional[StrictStr], Field(description="A where statement to select user specific STRDS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of all STRDS that are located in a specific location/mapset.

        Get a list of all STRDS that are located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param where: A where statement to select user specific STRDS
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StringListProcessingResultResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_get_serialize(
        self,
        location_name,
        mapset_name,
        where,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        # process the query parameters
        if where is not None:
            
            _query_params.append(('where', where))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_delete(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        recursive: Annotated[Optional[StrictBool], Field(description="Delete the STRDS and all registered raster map layer recursively")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProcessingResponseModel:
        """Delete a STRDS that is located in a specific location/mapset.

        Delete a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param recursive: Delete the STRDS and all registered raster map layer recursively
        :type recursive: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_delete_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            recursive=recursive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_delete_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        recursive: Annotated[Optional[StrictBool], Field(description="Delete the STRDS and all registered raster map layer recursively")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProcessingResponseModel]:
        """Delete a STRDS that is located in a specific location/mapset.

        Delete a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param recursive: Delete the STRDS and all registered raster map layer recursively
        :type recursive: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_delete_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            recursive=recursive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_delete_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        recursive: Annotated[Optional[StrictBool], Field(description="Delete the STRDS and all registered raster map layer recursively")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a STRDS that is located in a specific location/mapset.

        Delete a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param recursive: Delete the STRDS and all registered raster map layer recursively
        :type recursive: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_delete_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            recursive=recursive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_strds_name_delete_serialize(
        self,
        location_name,
        mapset_name,
        strds_name,
        recursive,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        if strds_name is not None:
            _path_params['strds_name'] = strds_name
        # process the query parameters
        if recursive is not None:
            
            _query_params.append(('recursive', recursive))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds/{strds_name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_get(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> STRDSInfoResponseModel:
        """Get information about a STRDS that is located in a specific

        Get information about a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRDSInfoResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_get_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[STRDSInfoResponseModel]:
        """Get information about a STRDS that is located in a specific

        Get information about a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRDSInfoResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_get_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get information about a STRDS that is located in a specific

        Get information about a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRDSInfoResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_strds_name_get_serialize(
        self,
        location_name,
        mapset_name,
        strds_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        if strds_name is not None:
            _path_params['strds_name'] = strds_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds/{strds_name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_post(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        metadata: Annotated[STRDSCreationModel, Field(description="Temporal type, title and description of the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProcessingResponseModel:
        """Create a new STRDS in a specific location/mapset.

        Create a new STRDS in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param metadata: Temporal type, title and description of the STRDS (required)
        :type metadata: STRDSCreationModel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_post_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            metadata=metadata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_post_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        metadata: Annotated[STRDSCreationModel, Field(description="Temporal type, title and description of the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProcessingResponseModel]:
        """Create a new STRDS in a specific location/mapset.

        Create a new STRDS in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param metadata: Temporal type, title and description of the STRDS (required)
        :type metadata: STRDSCreationModel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_post_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            metadata=metadata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_post_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        metadata: Annotated[STRDSCreationModel, Field(description="Temporal type, title and description of the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new STRDS in a specific location/mapset.

        Create a new STRDS in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param metadata: Temporal type, title and description of the STRDS (required)
        :type metadata: STRDSCreationModel
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_post_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            metadata=metadata,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_strds_name_post_serialize(
        self,
        location_name,
        mapset_name,
        strds_name,
        metadata,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        if strds_name is not None:
            _path_params['strds_name'] = strds_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if metadata is not None:
            _body_params = metadata


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/gml+xml', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds/{strds_name}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_delete(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        raster_list: Annotated[List[StrictStr], Field(description="The list of raster map layers to be unregistered from the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProcessingResponseModel:
        """Unregister raster map layers from a STRDS located in a specific

        Unregister raster map layers from a STRDS located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param raster_list: The list of raster map layers to be unregistered from the STRDS (required)
        :type raster_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_delete_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            raster_list=raster_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_delete_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        raster_list: Annotated[List[StrictStr], Field(description="The list of raster map layers to be unregistered from the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProcessingResponseModel]:
        """Unregister raster map layers from a STRDS located in a specific

        Unregister raster map layers from a STRDS located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param raster_list: The list of raster map layers to be unregistered from the STRDS (required)
        :type raster_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_delete_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            raster_list=raster_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_delete_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        raster_list: Annotated[List[StrictStr], Field(description="The list of raster map layers to be unregistered from the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unregister raster map layers from a STRDS located in a specific

        Unregister raster map layers from a STRDS located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param raster_list: The list of raster map layers to be unregistered from the STRDS (required)
        :type raster_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_delete_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            raster_list=raster_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_delete_serialize(
        self,
        location_name,
        mapset_name,
        strds_name,
        raster_list,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
            'raster_list': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        if strds_name is not None:
            _path_params['strds_name'] = strds_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if raster_list is not None:
            _body_params = raster_list


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/gml+xml', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds/{strds_name}/raster_layers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_get(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        where: Annotated[Optional[StrictStr], Field(description="A where statement to select user specific raster map layers from the STRDS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> STRDSRasterListResponseModel:
        """Get a list of all raster map layers that are registered in a STRDS

        Get a list of all raster map layers that are registered in a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param where: A where statement to select user specific raster map layers from the STRDS
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRDSRasterListResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_get_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        where: Annotated[Optional[StrictStr], Field(description="A where statement to select user specific raster map layers from the STRDS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[STRDSRasterListResponseModel]:
        """Get a list of all raster map layers that are registered in a STRDS

        Get a list of all raster map layers that are registered in a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param where: A where statement to select user specific raster map layers from the STRDS
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRDSRasterListResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_get_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        where: Annotated[Optional[StrictStr], Field(description="A where statement to select user specific raster map layers from the STRDS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a list of all raster map layers that are registered in a STRDS

        Get a list of all raster map layers that are registered in a STRDS that is located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param where: A where statement to select user specific raster map layers from the STRDS
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "STRDSRasterListResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_get_serialize(
        self,
        location_name,
        mapset_name,
        strds_name,
        where,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        if strds_name is not None:
            _path_params['strds_name'] = strds_name
        # process the query parameters
        if where is not None:
            
            _query_params.append(('where', where))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds/{strds_name}/raster_layers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_put(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        raster_list: Annotated[List[RasterListEntryModel], Field(description="The list of raster map layers to be registered in the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProcessingResponseModel:
        """Register raster map layers in a STRDS located in a specific

        Register raster map layers in a STRDS located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param raster_list: The list of raster map layers to be registered in the STRDS (required)
        :type raster_list: List[RasterListEntryModel]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_put_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            raster_list=raster_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_put_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        raster_list: Annotated[List[RasterListEntryModel], Field(description="The list of raster map layers to be registered in the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProcessingResponseModel]:
        """Register raster map layers in a STRDS located in a specific

        Register raster map layers in a STRDS located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param raster_list: The list of raster map layers to be registered in the STRDS (required)
        :type raster_list: List[RasterListEntryModel]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_put_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            raster_list=raster_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_put_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The name of the location")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS")],
        raster_list: Annotated[List[RasterListEntryModel], Field(description="The list of raster map layers to be registered in the STRDS")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Register raster map layers in a STRDS located in a specific

        Register raster map layers in a STRDS located in a specific location/mapset. Minimum required user role: user.

        :param location_name: The name of the location (required)
        :type location_name: str
        :param mapset_name: The name of the mapset (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS (required)
        :type strds_name: str
        :param raster_list: The list of raster map layers to be registered in the STRDS (required)
        :type raster_list: List[RasterListEntryModel]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_put_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            raster_list=raster_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessingResponseModel",
            '400': "ProcessingErrorResponseModel"
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_strds_name_raster_layers_put_serialize(
        self,
        location_name,
        mapset_name,
        strds_name,
        raster_list,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
            'raster_list': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        if strds_name is not None:
            _path_params['strds_name'] = strds_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if raster_list is not None:
            _body_params = raster_list


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/gml+xml', 
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds/{strds_name}/raster_layers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_render_get(
        self,
        location_name: Annotated[StrictStr, Field(description="The location name")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset that contains the required raster map layer")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS to render")],
        n: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Northern border")] = None,
        s: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Southern border")] = None,
        e: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Eastern border")] = None,
        w: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Western border")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Image width in pixel, default is 800")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Image height in pixel, default is 600")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Raster map layers that have equal or greater the start time will be rendered")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Raster map layers that have equal or lower the end time will be rendered")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Render the raster map layers of a specific STRDS as a single image.

        Render the raster map layers of a specific STRDS as a single image. All raster layers are rendered in order of their time stamps, from past to future. Minimum required user role: user.

        :param location_name: The location name (required)
        :type location_name: str
        :param mapset_name: The name of the mapset that contains the required raster map layer (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS to render (required)
        :type strds_name: str
        :param n: Northern border
        :type n: float
        :param s: Southern border
        :type s: float
        :param e: Eastern border
        :type e: float
        :param w: Western border
        :type w: float
        :param width: Image width in pixel, default is 800
        :type width: float
        :param height: Image height in pixel, default is 600
        :type height: float
        :param start_time: Raster map layers that have equal or greater the start time will be rendered
        :type start_time: str
        :param end_time: Raster map layers that have equal or lower the end time will be rendered
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_render_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            n=n,
            s=s,
            e=e,
            w=w,
            width=width,
            height=height,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_render_get_with_http_info(
        self,
        location_name: Annotated[StrictStr, Field(description="The location name")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset that contains the required raster map layer")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS to render")],
        n: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Northern border")] = None,
        s: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Southern border")] = None,
        e: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Eastern border")] = None,
        w: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Western border")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Image width in pixel, default is 800")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Image height in pixel, default is 600")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Raster map layers that have equal or greater the start time will be rendered")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Raster map layers that have equal or lower the end time will be rendered")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Render the raster map layers of a specific STRDS as a single image.

        Render the raster map layers of a specific STRDS as a single image. All raster layers are rendered in order of their time stamps, from past to future. Minimum required user role: user.

        :param location_name: The location name (required)
        :type location_name: str
        :param mapset_name: The name of the mapset that contains the required raster map layer (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS to render (required)
        :type strds_name: str
        :param n: Northern border
        :type n: float
        :param s: Southern border
        :type s: float
        :param e: Eastern border
        :type e: float
        :param w: Western border
        :type w: float
        :param width: Image width in pixel, default is 800
        :type width: float
        :param height: Image height in pixel, default is 600
        :type height: float
        :param start_time: Raster map layers that have equal or greater the start time will be rendered
        :type start_time: str
        :param end_time: Raster map layers that have equal or lower the end time will be rendered
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_render_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            n=n,
            s=s,
            e=e,
            w=w,
            width=width,
            height=height,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def locations_location_name_mapsets_mapset_name_strds_strds_name_render_get_without_preload_content(
        self,
        location_name: Annotated[StrictStr, Field(description="The location name")],
        mapset_name: Annotated[StrictStr, Field(description="The name of the mapset that contains the required raster map layer")],
        strds_name: Annotated[StrictStr, Field(description="The name of the STRDS to render")],
        n: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Northern border")] = None,
        s: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Southern border")] = None,
        e: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Eastern border")] = None,
        w: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Western border")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Image width in pixel, default is 800")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Image height in pixel, default is 600")] = None,
        start_time: Annotated[Optional[StrictStr], Field(description="Raster map layers that have equal or greater the start time will be rendered")] = None,
        end_time: Annotated[Optional[StrictStr], Field(description="Raster map layers that have equal or lower the end time will be rendered")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Render the raster map layers of a specific STRDS as a single image.

        Render the raster map layers of a specific STRDS as a single image. All raster layers are rendered in order of their time stamps, from past to future. Minimum required user role: user.

        :param location_name: The location name (required)
        :type location_name: str
        :param mapset_name: The name of the mapset that contains the required raster map layer (required)
        :type mapset_name: str
        :param strds_name: The name of the STRDS to render (required)
        :type strds_name: str
        :param n: Northern border
        :type n: float
        :param s: Southern border
        :type s: float
        :param e: Eastern border
        :type e: float
        :param w: Western border
        :type w: float
        :param width: Image width in pixel, default is 800
        :type width: float
        :param height: Image height in pixel, default is 600
        :type height: float
        :param start_time: Raster map layers that have equal or greater the start time will be rendered
        :type start_time: str
        :param end_time: Raster map layers that have equal or lower the end time will be rendered
        :type end_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._locations_location_name_mapsets_mapset_name_strds_strds_name_render_get_serialize(
            location_name=location_name,
            mapset_name=mapset_name,
            strds_name=strds_name,
            n=n,
            s=s,
            e=e,
            w=w,
            width=width,
            height=height,
            start_time=start_time,
            end_time=end_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _locations_location_name_mapsets_mapset_name_strds_strds_name_render_get_serialize(
        self,
        location_name,
        mapset_name,
        strds_name,
        n,
        s,
        e,
        w,
        width,
        height,
        start_time,
        end_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if location_name is not None:
            _path_params['location_name'] = location_name
        if mapset_name is not None:
            _path_params['mapset_name'] = mapset_name
        if strds_name is not None:
            _path_params['strds_name'] = strds_name
        # process the query parameters
        if n is not None:
            
            _query_params.append(('n', n))
            
        if s is not None:
            
            _query_params.append(('s', s))
            
        if e is not None:
            
            _query_params.append(('e', e))
            
        if w is not None:
            
            _query_params.append(('w', w))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if start_time is not None:
            
            _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            
            _query_params.append(('end_time', end_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'image/png'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/locations/{location_name}/mapsets/{mapset_name}/strds/{strds_name}/render',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


